#!/usr/bin/python3.4

import os

os.environ['CONFIGURATION_LIBRARY_PATH'] = '@CONFIGURATION_LIBRARY_PATH@'
os.environ['CONFIGURATION_PATH'] = '@CONFIGURATION_PATH@'
os.environ['LOADER_LIBRARY_PATH'] = '@LOADER_LIBRARY_PATH@'
os.environ['LOADER_SCRIPT_PATH'] = '@LOADER_SCRIPT_PATH@'

import unittest
import @PY_PORT_NAME@ as metacall

class py_port_test(unittest.TestCase):

	# MetaCall (Python from memory)
	def test_python_memory(self):
		script = ('#!/usr/bin/python3.4\n'
			'def inline_multiply_mem(left: int, right: int) -> int:\n'
			'	return left * right;\n');

		self.assertEqual(metacall.metacall_load_from_memory('py', script), 0);

		self.assertEqual(metacall.metacall('inline_multiply_mem', 2, 2), 4);

	# MetaCall (Python)
	def test_python(self):
		self.assertEqual(metacall.metacall_load_from_file('py', ['example.py']), 0);

		self.assertEqual(metacall.metacall('hello'), None);

		self.assertEqual(metacall.metacall('multiply', 5, 7), 35);

	# MetaCall (Ruby)
	def test_ruby(self):
		self.assertEqual(metacall.metacall_load_from_file('rb', ['hello.rb']), 0);

		self.assertEqual(metacall.metacall('say_null'), None);

		# TODO: Solve None return
		#self.assertEqual(metacall.metacall('say_multiply', 3, 4), 12);
		self.assertEqual(metacall.metacall('say_multiply', 3, 4), None);

		# TODO: Solve None return
		#self.assertEqual(metacall.metacall('say_hello', 'world'), 'Hello world!');
		self.assertEqual(metacall.metacall('say_hello', 'world'), None);

if __name__ == '__main__':
	unittest.main()
